%{
#include <asm/unistd.h>
#include "linux/compat_unistd.h"
#include <linux/ipc.h>
#include <linux/file.h>
#include <net/sock.h>
#include <linux/un.h>
#include <linux/tcp.h>
#ifdef CONFIG_USER_NS
#include <linux/user_namespace.h>
#endif
#ifdef STAPCONF_LINUX_UIDGID_H
#include <linux/uidgid.h>
#endif
#define PR_SET_MM               35
# define PR_SET_MM_START_CODE           1
# define PR_SET_MM_END_CODE             2
# define PR_SET_MM_START_DATA           3
# define PR_SET_MM_END_DATA             4
# define PR_SET_MM_START_STACK          5
# define PR_SET_MM_START_BRK            6
# define PR_SET_MM_BRK                  7
# define PR_SET_MM_ARG_START            8
# define PR_SET_MM_ARG_END              9
# define PR_SET_MM_ENV_START            10
# define PR_SET_MM_ENV_END              11
# define PR_SET_MM_AUXV                 12
# define PR_SET_MM_EXE_FILE             13
# define PR_SET_MM_MAP                  14
# define PR_SET_MM_MAP_SIZE             15
%}

function task_file_handle_d_path:string (task:long, fd:long) %{ /* pure */
	struct task_struct *p = (struct task_struct *)((long)STAP_ARG_task);
	struct files_struct *files;
	char *page = NULL;
	struct file *filp;
	struct dentry *dentry;
	struct vfsmount *vfsmnt;
	char *path = NULL;

	rcu_read_lock();
	if ((files = kread(&p->files)) &&
	    // We need GFP_ATOMIC since we're inside a lock so we
	    // can't sleep.
	    (page = (char *)__get_free_page(GFP_ATOMIC)) &&
	    (filp = fcheck_files(files, STAP_ARG_fd))) {

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
		/* git commit 9d1bc601 */
		path = d_path(&filp->f_path, page, PAGE_SIZE);
#else
		dentry = kread(&filp->f_dentry);
		vfsmnt = kread(&filp->f_vfsmnt);

		if (dentry && vfsmnt) {
			path = d_path(dentry, vfsmnt, page, PAGE_SIZE);
		}
#endif
		if (path && !IS_ERR(path)) {
			snprintf(STAP_RETVALUE, MAXSTRINGLEN, "%s", path);
		}
	}
	CATCH_DEREF_FAULT();

	if (page) free_page((unsigned long)page);

	rcu_read_unlock();
%}

function filtout_richfs(execname)
{
  if (execname == "stapio" || execname == "stap" ||execname == "alps")
  return 1;
}

probe kprocess.create
{
  if (filtout_richfs(execname())) next;

  timestamp=gettimeofday_us()
  sts = sprintf("%d", timestamp);
  snpid = sprintf("%d", new_pid);
  spid = sprintf("%d", pid());

  # new_pid = new process Id; pid() = current process Id,
  printf("%c%s%c%s%c%s\n", 97, snpid, 3, sts, 3, spid);
}

probe syscall.exit_group
{
  if (filtout_richfs(execname())) next;
  timestamp = gettimeofday_us();
  tts = sprintf("%d", timestamp);
  spid = sprintf("%d", pid());
  printf("%c%s%c%s\n", 98, spid, 3, tts);
}

probe nd_syscall.execve
{
  if (filtout_richfs(execname())) next;

  timestamp=gettimeofday_us();
  tts = sprintf("%d", timestamp);
  spid = sprintf("%d", pid());
  env = sprintf("PBS_JOBID=%s;PBS_JOBNAME=%s;PBS_JOBCOOKIE=%s", env_var("PBS_JOBID"), env_var("PBS_JOBNAME"), env_var("PBS_JOBCOOKIE"));
  printf("%c%s%c%s%c%s%c%s%c%s%c%s%c%s\n", 99, spid, 3, tts, 3, execname(), 3, argstr, 3, env, 3, filename, 3, args);
}

probe nd_syscall.execve.return
{
  if (filtout_richfs(execname())) next;

  timestamp=gettimeofday_us();
  tts = sprintf("%d", timestamp);
  spid = sprintf("%d", pid());
  env = sprintf("PBS_JOBID=%s;PBS_JOBNAME=%s;PBS_JOBCOOKIE=%s", env_var("PBS_JOBID"), env_var("PBS_JOBNAME"), env_var("PBS_JOBCOOKIE"));
  printf("%c%s%c%s%c%s%c%s\n", 100, spid, 3, tts, 3, retstr, 3, env);
}

#probe syscall.close.return
probe kernel.function("sys_close")
{
  if (filtout_richfs(execname())) next;

  timestamp=gettimeofday_us();
  tts = sprintf("%d", timestamp);

  try {
  	filename=task_file_handle_d_path(task_current(), $fd);
  	fds = sprintf("%d", $fd);
  	spid = sprintf("%d", pid());
  	if (filename == "") filename = "UNDEFINED";
	printf("%c%s%c%s%c%s%c%s\n", 103, spid, 3, tts, 3, filename, 3, fds);
  } catch (msg) {
  	printf("%c%s%c%s%c%s%c%s\n", 103, spid, 3, tts, 3, "null", 3, fds);
  }
}


#probe syscall.close
#{
#  if (filtout_richfs(execname())) next;
#
#  try {
#    timestamp=gettimeofday_us();
#    tts = sprintf("%d", timestamp);
#    spid = sprintf("%d", pid());
#    fds = sprintf("%d", $fd);
#  	file = @cast(task_current(), "task_struct")->files->fdt->fd[$fd];
#  	if (file == 0) next;
#  	filename=task_dentry_path(task_current(), @cast(file, "file")->f_path->dentry, @cast(file, "file")->f_path->mnt);
#  	if (filename == "") filename = "UNDEFINED";
#
#	printf("%c%s%c%s%c%s%c%s\n", 103, spid, 3, tts, 3, filename, 3, fds);
#  } catch (msg) {
#  	printf("%c%s%c%s%c%s%c%s\n", 103, spid, 3, tts, 3, msg, 3, fds);
#  }
#}


#probe kernel.function("do_filp_open")
#probe kernel.function("do_filp_open").return
probe kernel.function("do_sys_open").return
{
  if (filtout_richfs(execname())) next;
  timestamp=gettimeofday_us();
  spid = sprintf("%d", pid());
  tts = sprintf("%d", timestamp);
  flag = sprintf("%d", $flags);

  #if (!errno_p($return))
  if ($return != -1)
  {
    filename=task_file_handle_d_path(task_current(), $return); #$return is the fd
    fds = sprintf("%d", $return);
    printf("%c%s%c%s%c%s%c%s%c%s\n", 101, spid, 3, tts, 3, filename, 3, fds, 3, flag);
  }
}

#probe kernel.function("do_filp_open").return
#{
#  if (filtout_richfs(execname())) next;
#  timestamp=gettimeofday_us();
#  spid = sprintf("%d", pid());
#  tts = sprintf("%d", timestamp);
#
#  if (!errno_p($return))
#  {
#    filename=task_dentry_path(task_current(), $return->f_path->dentry, $return->f_path->mnt);
#    flag = sprintf("%d", $flags);
#    fds = sprintf("%d", $dfd);
#    printf("%c%s%c%s%c%s%c%s%c%s\n", 101, spid, 3, tts, 3, filename, 3, fds, 3, flag);
#
#    #if ($flags == 0x1)  //first read
#	 #printf("%c%s%c%s%c%s%c%s\n", 101, spid, 3, tts, 3, filename, 3, flag);
#    #if ($flags == 0x2) //first write
#    #	printf("%c%s%c%s%c%s%c%s\n", 101, spid, 3, tts, 3, filename, 3, flag);
#    #if ($flags == 0x3) //first read/write
#  }
#}
