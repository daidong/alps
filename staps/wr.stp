%{
#include <linux/file.h>
#include <net/sock.h>
#include <linux/un.h>
#include <linux/tcp.h>
#ifdef CONFIG_USER_NS
#include <linux/user_namespace.h>
#endif
#ifdef STAPCONF_LINUX_UIDGID_H
#include <linux/uidgid.h>
#endif
%}

function task_file_handle_d_path:string (task:long, fd:long) %{ /* pure */
  struct task_struct *p = (struct task_struct *)((long)THIS->task);
  struct files_struct *files;
  char *page = NULL;
  struct file *filp;
  struct dentry *dentry;
  struct vfsmount *vfsmnt;
  char *path = NULL;

  rcu_read_lock();
  if ((files = kread(&p->files)) &&
      // We need GFP_ATOMIC since we're inside a lock so we
      // can't sleep.
      (page = (char *)__get_free_page(GFP_ATOMIC)) &&
      (filp = fcheck_files(files, THIS->fd))) {

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
    /* git commit 9d1bc601 */
    path = d_path(&filp->f_path, page, PAGE_SIZE);
#else
    dentry = kread(&filp->f_dentry);
    vfsmnt = kread(&filp->f_vfsmnt);

    if (dentry && vfsmnt) {
      path = d_path(dentry, vfsmnt, page, PAGE_SIZE);
    }
#endif
    if (path && !IS_ERR(path)) {
      snprintf(THIS->__retvalue, MAXSTRINGLEN, "%s", path);
    }
  }
  CATCH_DEREF_FAULT();

  if (page) free_page((unsigned long)page);

  rcu_read_unlock();
%}


function filtout_richfs(execname)
{
  if (execname == "stapio" || execname == "stap" ||execname == "alps")
  return 1;
}

#probe vfs.read.return
probe syscall.read.return
{
  if (filtout_richfs(execname())) next;

  try {
    if ($return > 0) {
      #filename=task_dentry_path(task_current(), $file->f_path->dentry, $file->f_path->mnt);
      filename=task_file_handle_d_path(task_current(), $fd);
      printf("%c%d %d %s\n", 112, pid(), gettimeofday_us(), filename);
    }
  } catch (msg) {
    printf("%c%d %d %s\n", 115, pid(), gettimeofday_us(), msg);
  }
}

#probe vfs.write.return
probe syscall.write.return
{
  if (filtout_richfs(execname())) next;

  timestamp=gettimeofday_us();
  spid = sprintf("%d", pid());
  tts = sprintf("%d", timestamp);

  try {
    if ($return > 0){
      #filename=task_dentry_path(task_current(), $file->f_path->dentry, $file->f_path->mnt);
      filename=task_file_handle_d_path(task_current(), $fd);
      printf("%c%d %d %s\n", 113, pid(), gettimeofday_us(), filename);
    }
  } catch (msg) {
    printf("%c%d %d %s\n", 115, pid(), gettimeofday_us(), msg);
  }
}
